(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{640:function(t,s,e){"use strict";e.r(s);var a=e(46),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"手把手教你设置双屏幕-从理论到实践"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手把手教你设置双屏幕-从理论到实践"}},[t._v("#")]),t._v(" 手把手教你设置双屏幕——从理论到实践")]),t._v(" "),e("p",[t._v("前段时间因工作需要，买了一个显示器，准备外接到我的笔记本电脑上作双屏幕。KuaKuaKua 线装完之后，显示器提示没信号，笔记本也检测不到显示器连接的信息。这可坏了！在网上尝试了各种方法都无果，我都一度以为是新买的显示器有问题，不过最后还是在朋友 "),e("a",{attrs:{href:"liuxj@smail.nju.edu.cn"}},[t._v("鸡哥")]),t._v(" 的帮助下厘清了困难，解决了难题。")]),t._v(" "),e("p",[t._v("使用 Deepin 系统设置双屏幕确实颇费周折，不像 Windows 线一插上就万事大吉了。而且遇到问题也需要一些 Linux 相关的背景知识，才能自己着手解决。因此，这篇文章将会先从 Linux 显示设置的相关背景知识入手——"),e("a",{attrs:{href:"#x-window-system"}},[t._v("X Window System")]),t._v(" 和 "),e("a",{attrs:{href:"#xrandr"}},[t._v("XRandR")]),t._v("，然后再开始手把手讲解 "),e("a",{attrs:{href:"#%E5%BC%80%E5%A7%8B%E5%A4%9A%E5%B1%8F%E5%B9%95%E8%AE%BE%E7%BD%AE%E5%90%A7"}},[t._v("设置多屏幕的方法")]),t._v("。相比于直接告诉你怎么设置，本文还是倾向于先告诉你原理，然后再一步一步带你完成自己想要的设置。如果小伙伴对这些背景知识不感兴趣，可以直接跳过。")]),t._v(" "),e("p",[t._v("那事不宜迟，我们就开始吧！")]),t._v(" "),e("p",[e("font",{attrs:{color:"#6ba5fc",size:"4"}},[t._v("文章目录")])],1),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#x-window-system"}},[t._v("X Window System")]),e("ul",[e("li",[e("a",{attrs:{href:"#什么是-x-window-system"}},[t._v("什么是 X Window System？")])]),e("li",[e("a",{attrs:{href:"#配置-x-server"}},[t._v("配置 X Server")])]),e("li",[e("a",{attrs:{href:"#让我来康康-xorg-conf-写的啥"}},[t._v("让我来康康 xorg.conf 写的啥")])])])]),e("li",[e("a",{attrs:{href:"#xrandr"}},[t._v("XRandR")]),e("ul",[e("li",[e("a",{attrs:{href:"#这玩意儿怎么用"}},[t._v("这玩意儿怎么用？")])]),e("li",[e("a",{attrs:{href:"#哥追求的是个性化"}},[t._v("哥追求的是个性化")])]),e("li",[e("a",{attrs:{href:"#多显示器怎么设置呢"}},[t._v("多显示器怎么设置呢？")])])])]),e("li",[e("a",{attrs:{href:"#开始多屏幕设置吧"}},[t._v("开始多屏幕设置吧")]),e("ul",[e("li",[e("a",{attrs:{href:"#最简单的情况"}},[t._v("最简单的情况")])]),e("li",[e("a",{attrs:{href:"#如何保存配置"}},[t._v("如何保存配置？")])]),e("li",[e("a",{attrs:{href:"#复杂一点的情况"}},[t._v("复杂一点的情况")])]),e("li",[e("a",{attrs:{href:"#错误诊断"}},[t._v("错误诊断")])])])])])]),t._v(" "),e("br"),e("p"),t._v(" "),e("h2",{attrs:{id:"x-window-system"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#x-window-system"}},[t._v("#")]),t._v(" X Window System")]),t._v(" "),e("p",[t._v("要接触 Linux 系统桌面显示相关的设置，那就不得不先请出鼎鼎有名的 X Window System。")]),t._v(" "),e("h3",{attrs:{id:"什么是-x-window-system"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-x-window-system"}},[t._v("#")]),t._v(" 什么是 X Window System？")]),t._v(" "),e("p",[t._v("X Window System 是最早由 MIT 在1984年发展出来的一个基于网络架构的图形用户接口（Graphical User Interface, GUI）软件，可以说是历史十分悠久了。X Window System 简称为 X 或 X11。现在主流的 Linux 桌面系统，都基于 X 架构。因此，我们还是要了解一下 X Window System 比较好，这样系统的桌面环境出现了问题，我们才能找到办法去解决。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("这个图形用户接口为何称为 X 呢？因为 X 字母排在 W(indow) 后面，意味下一代的新窗口。称之为 X11 是因为在1987年的时候，X Window System 已经迭代到了第11个版本，后续所有的 X ，都是基于 X11 版本发展而来的（后续变动都比较小) 。")])]),t._v(" "),e("p",[t._v("我们可以使用如下命令来检查当前系统的 X 版本。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" X -version\n\nX.Org X Server "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.20")]),t._v(".4\nX Protocol Version "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v(", Revision "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\nBuild Operating System: Linux "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4.19")]),t._v(".0-6-server-amd64 x86_64 Uos\nCurrent Operating System: Linux aaron-PC "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5.4")]),t._v(".70-amd64-desktop "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#1 SMP Wed Oct 14 15:24:23 CST 2020 x86_64")]),t._v("\nKernel "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("command")]),t._v(" line: "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("BOOT_IMAGE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("/vmlinuz-5.4.70-amd64-desktop "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("root")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("UUID"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("a8a31905-1d52-441d-ae51-72ccd185ca09 ro splash quiet "),e("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("DEEPIN_GFXMODE")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\nBuild Date: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v(" November "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2020")]),t._v("  07:02:46AM\nxorg-server "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(":1.20.4.9-1+dde "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("https://www.debian.org/support"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \nCurrent version of pixman: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.36")]),t._v(".0\n        Before reporting problems, check http://wiki.x.org\n        to "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),t._v(" sure that you have the latest version.\n")])])]),e("p",[t._v("可以知道，我们的 Deepin 桌面基于的是 Xorg1.20.4 版本。如果遇到问题，可以到 "),e("a",{attrs:{href:"wiki.x.org"}},[t._v("wiki.x.org")]),t._v(" 网站上去查询。")]),t._v(" "),e("p",[t._v("X 架构主要由两个组件构成—— X Server 负责管理硬件，X Client 负责管理应用程序。在运行时，X Client 应用程序会将想要绘制的图形告知 X Server，最终由 X Server 来将结果通过它所管理的硬件绘制出来。X Server 主要管理的是显卡、屏幕分辨率、鼠标按键对应等。其中对于显卡的识别，尤其重要！我们想要部署好电脑上的显卡，就绕不开与 X Server 打交道。")]),t._v(" "),e("h3",{attrs:{id:"配置-x-server"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置-x-server"}},[t._v("#")]),t._v(" 配置 X Server")]),t._v(" "),e("p",[t._v("基本上，X Server 的配置文件都是默认放置在 "),e("code",[t._v("/etc/X11")]),t._v(" 目录下，管理硬件的总管模块放在 "),e("code",[t._v("/usr/lib64/xorg/modules")]),t._v(" 下面，显卡驱动模块就放在该目录下的 "),e("code",[t._v("drivers")]),t._v(" 文件夹中。X 使用了一个统一的配置文件来规范这些内容，这个配置文件就是 "),e("code",[t._v("/etc/X11/xorg.conf")]),t._v("。")]),t._v(" "),e("p",[t._v("现在 X Server 在每次启动时都会自行检查系统上的显卡、屏幕等信息，然后自行搭配优化的驱动程序进行加载。因此 "),e("code",[t._v("xorg.conf")]),t._v(" 这个配置文件在默认情况下是不需要的。不过如果你打算自行配置 X Server 的各项参数，可以在 "),e("code",[t._v("/etc/X11")]),t._v(" 目录下自行创建 "),e("code",[t._v("xorg.conf")]),t._v(" 。如果你只想加入或修改部分设置，那么可以在 "),e("code",[t._v("/etc/X11/xorg.conf.d")]),t._v(" 目录下建立后缀为 "),e("code",[t._v(".conf")]),t._v(" 的文件，将你需要的额外选项加进去就行了。这样一来，X Server 就不会每个设置都以 "),e("code",[t._v("xorg.conf")]),t._v(" 为主了。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("自行创建 "),e("code",[t._v("xorg.conf")]),t._v("？听起来好复杂，我怎么知道 "),e("code",[t._v("xorg.conf")]),t._v(" 里该写些什么东西？不用着急，实际上 X 会为我们准备好 "),e("code",[t._v("xorg.conf")]),t._v(" 的模板。我们首先要关闭 X Server，然后执行 "),e("code",[t._v("X --configure")]),t._v(" 命令，X 就会生成模板 "),e("code",[t._v("xorg.conf.new")]),t._v("，并告诉我们它存放的位置。我们只需要在模板上进行少量修改，然后放到 "),e("code",[t._v("/etc/X11")]),t._v(" 目录下改名为 "),e("code",[t._v("xorg.conf")]),t._v(" 就会生效啦！更多关于如何使用 "),e("code",[t._v("xorg.conf")]),t._v(" 的信息可以参见 "),e("a",{attrs:{href:"https://wiki.archlinux.org/index.php/xorg#Using_.conf_files",target:"_blank",rel:"noopener noreferrer"}},[t._v("Using .conf files"),e("OutboundLink")],1),t._v("。")])]),t._v(" "),e("p",[t._v("X Server 的日志信息在 "),e("code",[t._v("/var/log/Xorg.0.log")]),t._v(" 中。该文件前几行会说明使用的配置文件是来自哪里的，这样我们就知道该修改哪里的配置文件啦！")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("修改配置文件时，一定要提前做好备份！免得改错了什么东西，导致连 X Server 都无法启动了，那就糟糕了。")])]),t._v(" "),e("h3",{attrs:{id:"让我来康康-xorg-conf-写的啥"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#让我来康康-xorg-conf-写的啥"}},[t._v("#")]),t._v(" 让我来康康 xorg.conf 写的啥")]),t._v(" "),e("p",[t._v("xorg.conf 文件的内容是分成数个段落的，每个段落以 "),e("code",[t._v("Section")]),t._v(" 开始，以 "),e("code",[t._v("EndSection")]),t._v(" 结束，里面含有该段落相关的设定值，例如：")]),t._v(" "),e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[t._v("Section "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Section name"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\t\t"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" 与这个 Section name 有关的选项设置\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nEndSection\n")])])]),e("p",[t._v("常见的 Section 主要有：")]),t._v(" "),e("ol",[e("li",[t._v("Module：被加载到 X Server 当中的模块（某些功能的驱动程序）；")]),t._v(" "),e("li",[t._v("Monitor：显示器的格式，主要是设置刷新率，与硬件有关；")]),t._v(" "),e("li",[t._v("Device：这个重要，就是显卡的相关设置；")]),t._v(" "),e("li",[t._v("Screen：这个是在屏幕上显示的相关分辨率与色彩深度的设置选项，与显示设置相关；")]),t._v(" "),e("li",[t._v("Server Layout：上述的每个选项都可以重复设置，这里则是 X Server 要使用哪个选项值的设置。")])]),t._v(" "),e("p",[t._v("设置完成后，需要重启 X Server 才会生效。")]),t._v(" "),e("p",[t._v("xorg.conf 各个 Section 的作用以及详细可用参数，可以查阅 "),e("a",{attrs:{href:"https://www.x.org/releases/current/doc/man/man5/xorg.conf.5.xhtml",target:"_blank",rel:"noopener noreferrer"}},[t._v("xorg.conf 手册"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"xrandr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#xrandr"}},[t._v("#")]),t._v(" XRandR")]),t._v(" "),e("p",[t._v("XRandR 是 X11 提供的 RandR（Resize and Rotate）拓展配置工具。它可以被用来设置屏幕的大小、旋转，以及多屏幕显示。下面我们来看看 XRandR 的一些简单操作方法。")]),t._v(" "),e("h3",{attrs:{id:"这玩意儿怎么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这玩意儿怎么用"}},[t._v("#")]),t._v(" 这玩意儿怎么用？")]),t._v(" "),e("p",[t._v("使用 "),e("code",[t._v("xrandr")]),t._v(" 命令可以查看当前的显示参数。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr\nScreen "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(": minimum "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" x "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(", current "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3840")]),t._v(" x "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1080")]),t._v(", maximum "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("32767")]),t._v(" x "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("32767")]),t._v("\nDP-0 disconnected "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("normal left inverted right x axis y axis"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nHDMI-0 connected primary 1920x1080+1920+0 "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("normal left inverted right x axis y axis"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" 527mm x 293mm\n   1920x1080     "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("60.00")]),t._v("*+  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("74.99")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("59.94")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("50.00")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("60.00")]),t._v("    "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("50.04")]),t._v("  \n   1680x1050     "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("59.95")]),t._v("  \n   1600x900      "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("60.00")]),t._v(" \n…\n")])])]),e("p",[t._v("我们可以使用如下命令设置 "),e("code",[t._v("HDMI-0")]),t._v(" 的分辨率。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --output HDMI-0 --mode 1920x1080\n")])])]),e("p",[e("code",[t._v("--auto")]),t._v(" 参数可以打开指定的视频输出，并为其自动设置分辨率。关闭视频输出可以用 "),e("code",[t._v("--off")]),t._v(" 参数。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --output HDMI-0 --auto\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#打开 HDMI-0")]),t._v("\n$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --output HDMI-0 --off\t\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#关闭 HDMI-0")]),t._v("\n")])])]),e("p",[e("code",[t._v("--listproviders")]),t._v(" 参数可以查看当前的提供视频输出的设备（显卡）。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --listproviders\nProviders: number "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\nProvider "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(": id: 0x24e cap: 0x1, Source Output crtcs: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" outputs: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" associated providers: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" name:NVIDIA-0\nProvider "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(": id: 0x47 cap: 0xb, Source Output, Sink Output, Sink Offload crtcs: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" outputs: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" associated providers: "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" name:Intel\n")])])]),e("p",[t._v("更完整的 XRandR 使用方法，可以参见 "),e("a",{attrs:{href:"https://wiki.archlinux.org/index.php/xrandr",target:"_blank",rel:"noopener noreferrer"}},[t._v("XRandR 的 Archlinux百科"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"哥追求的是个性化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#哥追求的是个性化"}},[t._v("#")]),t._v(" 哥追求的是个性化")]),t._v(" "),e("p",[e("code",[t._v("1920x1080")]),t._v(" 是 XRandR 预设的一个显示器参数设置。如果要设置自己的想要的分辨率和刷新率，可以通过 "),e("code",[t._v("gtf")]),t._v(" 命令来得到相应的 mode 模板。"),e("code",[t._v("gtf")]),t._v(" 后面接三个参数——水平像素、垂直参数、刷新率。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用 1680x1050 的分辨率，使用 120Hz 的刷新率")]),t._v("\n$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" gtf "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1680")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1050")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("120")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1680x1050 @ 120.00 Hz (GTF) hsync: 135.00 kHz; pclk: 313.20 MHz")]),t._v("\n  Modeline "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1680x1050_120.00"')]),t._v("  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("313.20")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1680")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1816")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2000")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2320")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1050")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1051")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1054")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1125")]),t._v("  -HSync +Vsync\n")])])]),e("p",[t._v("然后将 Modeline 后面的内容复制下来，粘贴到 "),e("code",[t._v("xrandr")]),t._v(" 命令的 "),e("code",[t._v("--mode")]),t._v(" 后面，如下所示。运行即可。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --output HDMI-0 --mode "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("313.20")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1680")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1816")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2000")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2320")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1050")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1051")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1054")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1125")]),t._v("  -HSync +Vsync\n")])])]),e("h3",{attrs:{id:"多显示器怎么设置呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多显示器怎么设置呢"}},[t._v("#")]),t._v(" 多显示器怎么设置呢？")]),t._v(" "),e("p",[t._v("如果你是多显示器用户，XRandR 可以帮助你设置多个屏幕之间的相对位置（使用 "),e("code",[t._v("--right-of")]),t._v("、"),e("code",[t._v("--left-of")]),t._v("、"),e("code",[t._v("--above")]),t._v("、"),e("code",[t._v("--below")]),t._v(" 参数），或者设置屏幕绝对坐标（使用 "),e("code",[t._v("--pos")]),t._v(" 参数）。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 放置屏幕 HDMI-0 在屏幕 DP-0 的右边")]),t._v("\n$ xrandr --output DP-0 --auto --output HDMI-0 --auto --right-of DP-0\n")])])]),e("p",[t._v("更多多显示器的设置方法，可以参见 "),e("a",{attrs:{href:"https://wiki.archlinux.org/index.php/Multihead#Configuration_using_xrandr",target:"_blank",rel:"noopener noreferrer"}},[t._v("Configuration using xrandr"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("调整多屏幕间位置，推荐使用 XRandR 的可视化终端 ARandR，可以直观便捷地通过鼠标拖动设置屏幕直接的位置关系。使用 "),e("code",[t._v("sudo apt install arandr")]),t._v(" 指令进行下载。不推荐在 Deepin "),e("code",[t._v("设置-显示")]),t._v(" 中直接进行多屏幕调整，目前其功能不完善，漏洞百出。")])]),t._v(" "),e("h2",{attrs:{id:"开始多屏幕设置吧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开始多屏幕设置吧"}},[t._v("#")]),t._v(" 开始多屏幕设置吧")]),t._v(" "),e("p",[t._v("前面一口气讲了好多的背景知识，这一节我们就来看看，如何上手一步一步配置好我们的多屏幕吧～")]),t._v(" "),e("h3",{attrs:{id:"最简单的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#最简单的情况"}},[t._v("#")]),t._v(" 最简单的情况")]),t._v(" "),e("p",[t._v("假设我们的主机连有两个显示器，分别接在 HDMI 口和 DP 口上。设置步骤如下：")]),t._v(" "),e("ol",[e("li",[t._v("连接好主机与显示器。使用 "),e("code",[t._v("xrandr")]),t._v(" 命令检查 HDMI-0 和 DP-0 是否连接成功，连接成功的输出口会显示 "),e("code",[t._v("connected")]),t._v(" 字样，反之就为 "),e("code",[t._v("disconnected")]),t._v("。")]),t._v(" "),e("li",[t._v("设置屏幕之间的相对位置。（可以用下面的指令，也可以直接用 ARandR）")])]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 放置屏幕 HDMI-0 在屏幕 DP-0 的右边（屏幕拓展）")]),t._v("\n$ xrandr --output DP-0 --auto --output HDMI-0 --auto --right-of DP-0\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 屏幕 HDMI-0 和屏幕 DP-0 显示相同的内容（屏幕复制）")]),t._v("\n$ xrandr --output DP-0 --auto --output HDMI-0 --auto --same-as DP-0\n")])])]),e("p",[t._v("这样简单的两个步骤之后，多屏幕就设置好啦。但是，这样配置之后，每次重新启动电脑都需要重新配置一次，因为电脑并不会保存我们在控制台中的更改。那有没有办法使我们的配置永久生效呢？")]),t._v(" "),e("h3",{attrs:{id:"如何保存配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何保存配置"}},[t._v("#")]),t._v(" 如何保存配置？")]),t._v(" "),e("p",[t._v("实际上，我们有多种方法来预设好我们的屏幕扩展参数，在开机时让 X Server 自动调用，这样我们就不用每次开机都要输一遍指令啦！")]),t._v(" "),e("h4",{attrs:{id:"方法一-修改-xorg-配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法一-修改-xorg-配置"}},[t._v("#")]),t._v(" 方法一：修改 Xorg 配置")]),t._v(" "),e("p",[t._v("通过修改 Xorg 配置来让 X Server 每次启动时读取我们的设定配置，这是最正统的方法。由于只需要修改与显示相关的设置，因此我们选择在 "),e("code",[t._v("/etc/X11/xorg.conf.d/")]),t._v(" 目录下新建一个后缀为 "),e("code",[t._v(".conf")]),t._v(" 的配置文件，在文件中加入我们需要的选项即可。")]),t._v(" "),e("p",[t._v("以下是配置文件的范例。")]),t._v(" "),e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[t._v("Section "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ServerLayout"')]),t._v("\n    Identifier "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"layout"')]),t._v("\n\tScreen "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Screen0"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用 Screen0 作为主屏幕")]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Monitor"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 显示器")]),t._v("\n    Identifier "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"DP-0"')]),t._v(" \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Identifier 与 xrandr 输出中的名字保持一致")]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Monitor"')]),t._v("\n    Identifier  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"HDMI-0"')]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Device"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 显卡的驱动程序，很重要的设置")]),t._v("\n    Identifier  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Card0"')]),t._v("\n    Driver      "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"intel"')]),t._v("\t\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 实际使用的显卡驱动程序（Intel）")]),t._v("\n    BusID       "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"PCI:0:2:0"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 显卡总线ID（通过 lspci 命令查看）")]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Device"')]),t._v("\n    Identifier  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Card1"')]),t._v("\n    Driver      "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nvidia"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 实际使用的显卡驱动程序（NVIDIA）")]),t._v("\n    BusID       "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"PCI:1:0:0"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 显卡总线ID")]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Screen"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#与显示的界面有关")]),t._v("\n    Identifier "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Screen0"')]),t._v("\n    Device "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Card0"')]),t._v("\t\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用哪一个显卡")]),t._v("\n    Monitor "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"DP-0"')]),t._v("      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用哪一个显示器")]),t._v("\n    SubSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Display"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 此阶段的附属设置选项")]),t._v("\n    \tModes "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1920x1080"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 分辨率设置")]),t._v("\n    \tViewport "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\t\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 屏幕的左上角坐标")]),t._v("\n    EndSubSection\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Screen"')]),t._v("\n    Identifier "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Screen1"')]),t._v("\n    Device "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Card1"')]),t._v("\n    Monitor "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"HDMI-0"')]),t._v("\n    SubSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Display"')]),t._v("\n    \tModes "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"1920x1080"')]),t._v("\n    \tViewport "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1920")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" \t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# HDMI-0 屏幕设置在 DP-0 的屏幕右边")]),t._v("\n    EndSubSection\nEndSection\n")])])]),e("p",[t._v("如上内容中，我们将显示器 "),e("code",[t._v("DP-0")]),t._v(" 和 NVIDIA 显卡绑定在一起，显示器 "),e("code",[t._v("HDMI-0")]),t._v(" 和 Intel 显卡绑定在一起，设置 "),e("code",[t._v("DP-0")]),t._v(" 为主屏幕，并通过设置两者的显示坐标，来使得 "),e("code",[t._v("HDMI-0")]),t._v(" 屏幕显示在 "),e("code",[t._v("DP-0")]),t._v(" 屏幕右侧。文件保存后，重启系统便会生效。")]),t._v(" "),e("p",[t._v("两个屏幕的位置效果如下图所示。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("(0,0)-----------------+(1920,0)--------------+\n|                     ||                     |\n|     1920 x 1080     ||     1920 x 1080     |\n|         DP-0        ||       HDMI-0        |\n|                     ||                     |\n+---------------------++---------------------+\n")])])]),e("p",[t._v("自己编写 "),e("code",[t._v("xorg.conf")]),t._v(" 配置文件时，需要结合自己电脑的具体情况，正确配置显卡（Device）、显示器（Monitor）和屏幕（Screen）之间的关系。如果任何一项配置错误，都可能导致无法启动 X Server，从而无法进入到桌面。如果真的进入不到桌面了，只能进入命令行模式，修正 "),e("code",[t._v("xorg.conf")]),t._v(" 文件，使 X Server 能够正确启动。")]),t._v(" "),e("h4",{attrs:{id:"方法二-修改-lightdm-配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法二-修改-lightdm-配置"}},[t._v("#")]),t._v(" 方法二：修改 LightDM 配置")]),t._v(" "),e("p",[t._v("对于上一种方法的小伙伴，很有可能会担心自己文件编写错了怎么办，要是一通捯饬之后进不了桌面就不好弄了。所以，在这里提供一个更简单更安全的方法——修改 LightDM 的配置文件 "),e("code",[t._v("lightdm.conf")]),t._v("。")]),t._v(" "),e("p",[t._v("LightDM（Light Display Manager）是一个轻量级的 Linux 桌面的桌面显示管理器。 Deepin 使用的便是 LightDM 而非传统 Ubuntu 使用的 GDM。X Server 启动后，LightDM 便会启动。我们可以考虑将我们设置多屏幕的命令写在一个脚本中，让 LightDM 启动时执行该脚本，这样一来进入到桌面时，多屏幕就已经为我们设置好了。下面我们来看看具体应该怎么操作。")]),t._v(" "),e("p",[t._v("首先，新建一个文件作为我们的脚本文件，放到任何你喜欢的目录下。（例如放到 "),e("code",[t._v("/etc")]),t._v(" 目录下，取名为 "),e("code",[t._v("MonitorInit")]),t._v("）")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("touch")]),t._v(" /etc/MonitorInit\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 新建文件")]),t._v("\n")])])]),e("p",[t._v("打开文件，将需要执行的命令输入其中，一行放一个命令。保存。（范例如下）")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("xrandr --output HDMI-0 --auto --mode 1920x1080\nxrandr --output DP-0 --auto --mode 1920x1080\nxrandr --output HDMI-0 --right-of DP-0\n")])])]),e("p",[t._v("为该文件赋予可执行权限。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("chmod")]),t._v(" +x /etc/MonitorInit\n")])])]),e("p",[t._v("然后打开 LightDM 的配置文件 "),e("code",[t._v("lightdm.conf")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" code /etc/lightdm/lightdm.conf\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#使用 VScode 打开文件")]),t._v("\n")])])]),e("p",[t._v("找到其中的 "),e("code",[t._v("#display-setup-script=")]),t._v(" 一行，去掉 "),e("code",[t._v("#")]),t._v(" 注释，等号后面写入我们的创建的脚本的路径。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("display-setup-script"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/etc/MonitorInit"')]),t._v("\n")])])]),e("p",[t._v("保存。之后每次重启系统时，LightDM 都会自动执行我们脚本中的命令啦。")]),t._v(" "),e("p",[t._v("参考 "),e("a",{attrs:{href:"https://wiki.archlinux.org/index.php/Multihead#Configuration_using_xorg.conf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Configuration_using_xorg.conf"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("h4",{attrs:{id:"方法三-修改-profile-文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法三-修改-profile-文件"}},[t._v("#")]),t._v(" 方法三：修改 ~/.profile 文件")]),t._v(" "),e("p",[t._v("想要让 Linux 系统在开机时执行一些预定的命令，传统的方法是将命令写在 "),e("code",[t._v("~/.profile")]),t._v(" 文件中。")]),t._v(" "),e("p",[t._v("打开 "),e("code",[t._v("~/.profile")]),t._v(" 文件，将需要执行的命令写在文件的最后面。保存。需要注意的是，如果 "),e("code",[t._v("~/.bash_profile")]),t._v(" 和 "),e("code",[t._v("~/.bash_login")]),t._v(" 文件存在，需要删除这两个文件，否则 "),e("code",[t._v("~/.profile")]),t._v(" 文件中的内容不会被系统执行。")]),t._v(" "),e("p",[t._v("这种方法最简单，但是 "),e("code",[t._v("~/.profile")]),t._v(" 文件只有在用户登录后，才会被读取并执行。并且也只对一个用户生效。因此，如果想要命令在登录前被执行，还是推荐使用方法二。")]),t._v(" "),e("h3",{attrs:{id:"复杂一点的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复杂一点的情况"}},[t._v("#")]),t._v(" 复杂一点的情况")]),t._v(" "),e("p",[t._v("想象以下情况：学生小明是一个笔记本用户，他的笔记本电脑只能通过集成的 Intel GPU 访问 LVDS1（笔记本电脑内部屏幕）和 VGA 输出； HDMI 和 DP 输出口则连接到 NVIDIA 独立显卡。他将外接显示器连在了笔记本的 HDMI 输出口上，想要作为笔记本屏幕的扩展屏幕。但由于两个视频输出由两张显卡分别提供，因此 "),e("code",[t._v("xrandr")]),t._v(" 无法同时检测到两个输出口。")]),t._v(" "),e("p",[t._v("要解决这种情况，就需要用到下面这种称为 Reverse PRIME（翻转主要输出设备） 的方法。")]),t._v(" "),e("h4",{attrs:{id:"reverse-prime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reverse-prime"}},[t._v("#")]),t._v(" Reverse PRIME")]),t._v(" "),e("p",[t._v("对于有两个 GPU 的情况，如果第二个 GPU 具有主 GPU 无法访问的视频输出，则可以使用 Reverse PRIME 方法来使用它们——即使用主 GPU 渲染图像，然后将渲染好的图像传递给第二个 GPU。如下命令将会把 "),e("code",[t._v("provider")]),t._v(" 设置为 "),e("code",[t._v("output")]),t._v(" 的输出口。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --setprovideroutputsource provider "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("source")]),t._v("\n")])])]),e("p",[t._v("针对小明的情况，我们可以使用下面的命令，将集成显卡作为主 CPU 进行渲染图像的工作，独立显卡设置为集成显卡的输出口。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --setprovideroutputsource nvidia Intel\n")])])]),e("p",[t._v("执行完如上命令，独立显卡和集成显卡的输出就会同时出现在 "),e("code",[t._v("xrandr")]),t._v(" 中了。")]),t._v(" "),e("p",[t._v("小明非常开心，这下终于可以用上双屏幕了！")]),t._v(" "),e("p",[t._v("但是，使用性能较弱的集成显卡来进行图像渲染，性能较强的独立显卡反而只作为一个图像输出中介，好像不太对？")]),t._v(" "),e("h4",{attrs:{id:"独立显卡作为主显卡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#独立显卡作为主显卡"}},[t._v("#")]),t._v(" 独立显卡作为主显卡")]),t._v(" "),e("p",[t._v("让性能较弱的集成显卡来负责图像渲染，明显浪费了独立显卡的高性能。要让独立显卡来作为主要显卡，我们需要对 Xorg 配置进行修改。在 "),e("code",[t._v("/etc/X11/xorg.conf.d/")]),t._v(" 路径下创建一个后缀名为 "),e("code",[t._v(".conf")]),t._v(" 的文件，添加如下内容。")]),t._v(" "),e("div",{staticClass:"language-python extra-class"},[e("pre",{pre:!0,attrs:{class:"language-python"}},[e("code",[t._v("Section "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"ServerLayout"')]),t._v("\n    Identifier "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"layout"')]),t._v("\n    Screen "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nvidia"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# nvidia 设置为主屏幕")]),t._v("\n    Inactive "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"intel"')]),t._v("\t"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 禁用 intel 屏幕")]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Device"')]),t._v("\n    Identifier  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nvidia"')]),t._v("\n    Driver      "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nvidia"')]),t._v("\n    BusID       "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"PCI:1:0:0"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 根据自己电脑情况进行修改")]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Screen"')]),t._v("\n    Identifier "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nvidia"')]),t._v("\n    Device "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nvidia"')]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Device"')]),t._v("\n    Identifier  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"intel"')]),t._v("\n    Driver      "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"intel"')]),t._v("\n    BusID       "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"PCI:0:2:0"')]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 根据自己电脑情况进行修改")]),t._v("\nEndSection\n\nSection "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Screen"')]),t._v("\n    Identifier "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"intel"')]),t._v("\n    Device "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"intel"')]),t._v("\nEndSection\n")])])]),e("p",[t._v("保存并重启后，HDMI 和 DP 输出口成为了主输出，LVDS1 和 VGA 输出口被关闭。用如下命令重新启用它们。")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("$"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" xrandr --setprovideroutputsource Intel nvidia \n")])])]),e("p",[t._v("现在四个输出口就都被启用了。")]),t._v(" "),e("p",[t._v("内容参考自 "),e("a",{attrs:{href:"https://wiki.archlinux.org/index.php/PRIME#Reverse_PRIME",target:"_blank",rel:"noopener noreferrer"}},[t._v("Reverse PRIME"),e("OutboundLink")],1),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"错误诊断"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#错误诊断"}},[t._v("#")]),t._v(" 错误诊断")]),t._v(" "),e("p",[t._v("先写到这儿吧，写着好累啊～～剩下的内容以后再继续补充。")])])}),[],!1,null,null,null);s.default=r.exports}}]);