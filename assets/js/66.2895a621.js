(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{704:function(a,s,t){"use strict";t.r(s);var e=t(46),i=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[t("strong",[a._v("Codeanalysis工具的使用")])]),a._v(" "),t("p",[a._v("[TOC]")]),a._v(" "),t("h2",{attrs:{id:"工具的编译"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具的编译"}},[a._v("#")]),a._v(" 工具的编译")]),a._v(" "),t("p",[a._v("codeanalysis工具的Gitlab下载地址已经失效，请找作者sk，clone代码后进入源码目录, mkdir build cd build cmake ../ make sudo make install")]),a._v(" "),t("p",[a._v("编译安装完成后,在shell输入codeanalysis会显示帮助信息,表示安装正确.")]),a._v(" "),t("br"),a._v(" "),t("h2",{attrs:{id:"功能介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#功能介绍"}},[a._v("#")]),a._v(" 功能介绍")]),a._v(" "),t("h3",{attrs:{id:"分析代码修改可能引发的bug"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析代码修改可能引发的bug"}},[a._v("#")]),a._v(" 分析代码修改可能引发的bug")]),a._v(" "),t("p",[a._v("首先说明,这个对大型的比较稳定的工程适用,对于处于不稳定的在快速迭代的项目不适用,工具的分析会借助于git blame的分析结果 (git提交信息需要满足 fix,feat这样的提交规范.), 分析可能引发的bug,主要是基于这样一个假设,对于一个提交,如果在后续的提交中,在相近的地方再次做了修改,在一个大型的稳定的项目中, 这很可能就是之前的提交引发的问题导致的再次修改,这样的提交引发的问题越多,说明代码质量越低.codeanalysis就是统计分析这种可能引发问题提交的工具.")]),a._v(" "),t("p",[a._v("分析一个提交可能引发的bug, 输入命令 codeanalysis -b [commit id] , 举个例子,下面是一段分析结果,")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("e5b2b9f96 [OK]")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("9ddab91d7 [OK]")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("18439a0b1 [WARNING]")]),a._v(" "),t("p",[a._v("[ 可能引发的问题如下 ]")]),a._v(" "),t("p",[a._v("745ef9bbb7 fix(bluetooth): 修复【uos-20-pangu-daliy-20200427-build47】连接蓝牙设备过程中开关蓝牙，概率导致任务栏崩溃")]),a._v(" "),t("p",[a._v("如果工具分析一个提交正常就显示[OK] ,如果有问题,就显示 [WARNING] , [可能引发的问题如下] 下面显示的就是引发的后续fix提交信息. 这里提供一个分析前100个git提交的命令,")]),a._v(" "),t("p",[a._v('git log --oneline | head -100 | grep -oP "^\\w+" | xargs codeanalysis -b -V')]),a._v(" "),t("p",[a._v("这里加了一个-V参数会打印额外的一些信息.")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"分析代码注释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分析代码注释"}},[a._v("#")]),a._v(" 分析代码注释")]),a._v(" "),t("p",[a._v("这个功能主要是为了分析一下代码的注释情况,看是否代码注释太少甚至是没注释, 命令比较简单 codeanalysis -n fileName ,fileName是文件名加路径, 如果加-V参数会打印出注释内容, 这里需要说明的是,这里的注释行数统计会忽略掉源码文件开头的版权声明. 如果需要统计大量的源码文件,可以结合find命令,比如 : 在源码目录下执行")]),a._v(" "),t("p",[a._v("find . -type f -name '*.cpp' | xargs codeanalysis -n")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"统计一段时间内开发人员fix-bug的数量和修改的文件信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#统计一段时间内开发人员fix-bug的数量和修改的文件信息"}},[a._v("#")]),a._v(" 统计一段时间内开发人员fix bug的数量和修改的文件信息")]),a._v(" "),t("p",[a._v("计算统计开发人员fix bug的数量,这里只会统计git提交信息中fix开头的提交,如果提交信息不满足提交规范,统计信息可能会有错误, 比如我要统计最近60天内开发人员fix bug的情况,在工程目录下,可以这样 codeanalysis -c -s 60.days ./ 如果需要详细信息加 -V参数 ,如果需要更加精细的控制,比如只看某一个开发的提交信息,可以加-a参数,也就是--author,这个和git中的--author参数的含义一致.")]),a._v(" "),t("br"),a._v(" "),t("h3",{attrs:{id:"单词拼写错误的检测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单词拼写错误的检测"}},[a._v("#")]),a._v(" 单词拼写错误的检测")]),a._v(" "),t("p",[a._v("对于单词拼写错误的检测,这个有现成的工具,codespell ,UOS可以直接 sudo apt install安装,codeanalysis主要使用这个进行检测, 然后对输出进行适当的格式化,可以使用如下命令:假如当前目录有文件main.cpp ,codeanalysis -w main.cpp")])])}),[],!1,null,null,null);s.default=i.exports}}]);